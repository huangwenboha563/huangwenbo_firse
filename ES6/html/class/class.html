<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>class类</title>
</head>
<body>


</body>
<script>

    // -> 传统方式的继承方法之一(call继承)  开胃菜
    function Person(name, age) {
        // 这三个都是私有的属性和方法
        this.name = name;
        this.age = age;
        this.a = function () {
            console.log(this.name)
        }
    }
    Person.xxx = 111111111111;
    Person.prototype = {
        // 共有的属性和方法
        constructor: Person,
        showName: function () {
            var _this = this;
            console.log(_this.name)
        }
    }

    var personDemo = new Person();
    console.log(personDemo.xxx);




















    function Manager(name, age) {
        Person.call(this, name, age);
    }
    var son = new Manager('hwb', 20);
    console.log(son.name); // 继承私有的成为私有的，所以有值
    console.log(son.age); // 继承私有的成为私有的，所以有值
    son.a(); // 继承私有的成为私有的所以有这个方法
    // son.showName(); // 把公有的继承过来成为自己私有的是不允许的所以会报错
</script>
<script>
    // ----------------es6里面的class
    // -> 什么是静态方法？
    class Father {
        constructor(name,age) {
            this.name = name;
            this.age = age;
        }
        eat(){
            console.log(this.name)
        }
        static drink(){
            return 'hello'
        }
    }
    let f = new Father('hwb',18)
    class Son extends Father{
        constructor(name,age,sex){
            super(name,age)
            this.sex = sex;
        }
    }
    let s = new Son('zjh',10,'男')
    console.log(s.name,s.age)
    s.eat();
    // f.drink(); 静态方法不能通过实例来调用
    // s.drink(); 更不可能被继承了
</script>
</html>
