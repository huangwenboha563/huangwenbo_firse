<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>预解释</title>
</head>
<body>

</body>
<script>
	//老声常谈  js中的数据类型(基本数据类型 & 引用数据类型)


	// 预解释(预解析或变量提升)

	// 引导 基本数据类型操作的是值，引用数据类型操作的是地址

	// 当浏览器加载html页面的时候，首先会提供一个供全局js代码执行的环境->全局作用域(global/window)

	// 基本数据类型存的是值

	// 引用数据类型存的是地址
	/*

	var number = 10;
	var obj = {name:"huangwenbo",age:26};
	function fn () {
		console.log('不忘初心，方得始终~~');
	}
	console.log(fn)   // fn 代表当前函数本身(实际上就是栈内存的一个地址)
	console.log(fn()) // 先输出“不忘初心，方得始终~~” ,再输出undefined->因为fn()执行的结果没有返回值

	*/

	// q:什么叫做预解释？
	// a:在当前作用域中，浏览器首先会默认的把所有带 var 和 function 进行提前的声明或定义
	//1）理解声明和定义（大白话来理解:同志们听好了，我准备在南海边画一个圈啊，然后开始建设城市，这样深圳就开始发展了）
	// var num = 12;
	// declare var num;
	// defined num = 12;
	//2)对于带var关键字的和待function的关键词的在预解释的时候还不太一样
	// var -> 在预解释的时候只是提前的声明
	// function -> 在预解释的时候声明和定义都完成了

	/*

	var number = 10;
	var obj = {name:"huangwenbo",age:26};
	function fn (num1,num2) {
		var total = num1 + num2;
		console.log(total);
	}

	1. var num;var obj;fn="一个栈内存地址"->对应地址的堆中存的是函数体内的“代码字符串”
	2. 预解释之后代码从上到下开始执行: number = 10; obj = "一个栈内存地址"->对应地址的堆中存的是函数体内的属性名和属性值
	3. 预解释只发生在当前作用域下例如:开始只对window下进行预解释，只有函数执行的时候才会对函数中的进行预解释

	*/

	/*

	var box = function () {
		console.log('理解自变量声明函数为什么要在声明后才调用');
		// 这就和预解释有关系了，看上面的预解释的概念。预解释的时候 var 只声明不定义
	}
	box(); // 如果box() 放在函数申明的前面就会报错

	*/

	/*

	// box() // 这里调用也可以
	function box () {
		console.log('理解这种方式声明的函数为什么在前面和后面都可以调用');
		// 这就和预解释有关系了，看上面的预解释的概念。预解释的时候 var 只声明不定义，但是这种方式声明的函数是声明+定义
	}

	// box() // 这里调用也可以
	*/



	// 补充js中内存的分类？内存的释放？

	// 栈内存

	// 用来提供一个供js代码执行的环境->作用域(全局，局部也叫私有也叫函数)->预解释发生在栈内存中


	// 堆内存

	// 用来存储对象数据类型的值->对象存储的是属性名和属性值，函数存储的是代码字符串...


	// var obj = {}  obj在堆里面存的地址



</script>
</html>
