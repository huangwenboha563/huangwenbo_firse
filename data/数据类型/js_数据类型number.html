<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>数据类型分类-number类型</title>
</head>
<body>
	
</body>
<script>
	// --number类型的细节知识点

	// 什么样的值算是number？ 
	/*
		正数   1 
		负数   -1 -1.3 
		0     0
		小数   1.3
		
		NaN 不是一个有效数字 not a number，但是它也属于number数据类型的。
	*/

	// NaN == NaN 是不相等的。
	// isNaN() 是一个方法，检测一个值是不是有效数字的命题是否成立！  true ->不是      false ->是
	/*
		isNaN(12)    ->false
		isNaN('12')  ->fasle 明明是带引号的12为什么返回false呢？
		isNaN(true)  ->false
		
		// 分析过程涉及到强制类型的转换
		过程:如果检测的值不是number类型的，浏览器会默认的把它转换成number类型，然后再判断是否为有效数字。
		过程:先把'12' 用(强制类型转换)Number()转换成number类型 也就是Number('12') ->12

		Number(准备转换的),强制类型转换的规则
		// Number('12')    ->12
		// Number('12px')  ->NaN
		// Number(true)    ->1
		// Number(false)   ->0
		// Number("")      ->0
		
	*/

	// 非强制类型转换 parseInt()/parseFloat()
	// 转换规则:从左到右，一个个字符查找，把是数字的转换为有效的数字，中途如果遇到了一个非有效数字就不再继续查找了。
	/*
		//parseInt('12px')            ->12   typeof(parseInt('12px')) ->number
		//parseInt('12px13')          ->12   中途遇到非有效数字   px
		//parseInt('breadoffer2017')  ->NaN  刚上来就遇到非有效数字breadoffer
		//parseInt('12.5px')          ->12   已经遇到了非有效数字 .   此时应该用parseFloat()
	*/
	/*

	
	var val = Number('12px');
	if (val == 12) {
		console.log(12);
	}else if (val == NaN){
		console.log(NaN)
	}else {
		console.log('以上都不是');
	}
	知识点1:  Number() 数据类型强制转换规则的结果是NaN
	知识点2:  NaN不等于12  但是NaN是不等于NaN的 也就是NaN==NaN的结果是false
	*/
</script>
</html>