<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
<script>
    /*闭包的作用
     *
     *  1.保护   自执行函数保护私有作用域
     *  2.保存 （比如选项卡，保存一下那个 索引(index) i）
     *  函数执行形成一个私有作用域，执行完成，形成的这个栈内存一般情况下都会自动释放
     *  如何保证函数执行完成，私有作用域(栈内存)中的某部分内容比如变量、元素事件占用了。那么这个栈内存就不能销毁了
     *  也就形成了不销毁的作用域(里面的私有变量也不会销毁)
     *
     *  i ++ 和 ++i
     *
     *  i++  先拿原有的i值和其他值进行运算，运算完成后再自身加1
     *  var i = 5;  5+ i++ => 5+5 10    i=>6
     *
     *  ++i  先自身累加1，然后累加完成的结果和其他值进行运算
     *  var i = 5;  5+ ++i => 5+6 11    i=>6
     * */
    var i = 5;
    console.log(10 + (++i) + (i++) + 5 + (i++) + (++i));
    /*
    10 + 6
    16 + 6
    22 + 5
    27 + 7
    34 + 9
    */
    function fn() {
        var i = 1;
        return function (n) {
            console.log(n + i++);
        }
    }
    var f = fn();   // 重点是一旦调用f之后  形成的作用域不销毁
    f(10);
    fn()(10);
    f(20);
    fn()(20);
    fn()(30);
    /*
    *   1.保护
    *
    *   团队协作开发，每个开发者b把自己的代码存放在一个私有的作用域中，防止相互之家的冲突；
    *   把需要别人使用的方法，通过return或者 window.xxx 暴露在全局下即可
    *
    *   2.保存
    *   保存比如:利用闭包 保存那个索引(index) i
    *   惰性思想/函数科理化函数
    */
</script>
</html>