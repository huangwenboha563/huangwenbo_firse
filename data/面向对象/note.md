# js 面向对象

## 原型相关知识

> 记住下面三句话不需要问为什么因为js就是这样规定的

1.  每一个函数数据类型(普通函数、构造函数)都有一个天生自带的属性prototype(原型)，并且这个属性是个对象数据类型的值
2.  并且在prototype上浏览器天生给他加了一个属性constructor(构造函数的意思)、属性值就是当前构造函数(类本身)
3.  每一个对象数据类型(普通的对象、实例、prototype)也天生自带一个属性__proto__，属性值是当前实例所属类的原型(prototype)
注意一点:Object这个基类的原型prototype上没有__proto__这个属性是->null，因为自己指向自己没有任何意思

> 原型链模式查找机制

1. 通过->对象名.属性名获取属性值的时候首先在对象的私有属性上进行查找，如果私有的属性中存在这个属性，则获取的是私有的属性值
2. 如果私有的没有，再通过__proto__找到所属类的原型(类原型上定义的属性和方法都是当前实例公有的属性和方法)，原型上获取到的是公有的属性值
3. 如果原型上也没有，则继续通过原型上的(因为原型也是个对象，只要是对象就有__proto__这个属性)__proto__继续向上查找，直到知道到Object.prototype上查找还没有就是undefined

> 注意

```
// 这样写不对，不起作用，表面上看上去是给原型重新开辟了堆内存，其实浏览器是屏蔽的，你改不掉
Array.prototype = {
    constructor:Array,
    unique:function(){
        
    }
}
// 但是我们通过下面的方式，在数组的原型上增加方法，如果方法名重复了，会把人家内置的修改掉，->我们以后在内置类上增加方法加一个特殊的标识比如mySort
Array.prototype.sort = function() {
    console.log('aaa')
}
```

> for in 循环在遍历的时候可以把自己私有的和他所属类的原型上扩展的属性方法都可以遍历到~

> 但是一般情况下我们遍历一个对象只需要遍历私有的即可

> 继承的六种方式